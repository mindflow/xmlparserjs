import{Logger,Map,StringUtils,List}from"./coreutil_v1.js";class ReadAhead{static read(t,e,n,i=!1){let r=n;for(let n=0;n<e.length&&n<t.length;n++){for(;i&&" "==t.charAt(r);)r++;if(t.charAt(r)!=e.charAt(n))return-1;r++}return r-1}}class XmlAttribute{constructor(t,e,n){this.name=t,this.namespace=e,this.value=n}}const LOG=new Logger("ElementBody");class ElementBody{constructor(){this.name=null,this.namespace=null,this.attributes=new Map}detectPositions(t,e,n){let i=n,r=null;for(;StringUtils.isInAlphabet(e.charAt(n))&&n<e.length;)n++;if(":"==e.charAt(n))for(LOG.debug(t,"Found namespace"),n++;StringUtils.isInAlphabet(e.charAt(n))&&n<e.length;)n++;return r=n-1,this.name=e.substring(i,r+1),this.name.indexOf(":")>-1&&(this.namespace=this.name.split(":")[0],this.name=this.name.split(":")[1]),n=this.detectAttributes(t,e,n)}detectAttributes(t,e,n){let i=null;for(;-1!=(i=this.detectNextStartAttribute(t,e,n));){n=this.detectNextEndAttribute(t,e,i);let r=null,s=e.substring(i,n+1);s.indexOf(":")>-1&&(r=s.split(":")[0],s=s.split(":")[1]),LOG.debug(t,"Found attribute from "+i+"  to "+n),n=this.detectValue(s,r,t,e,n+1)}return n}detectNextStartAttribute(t,e,n){for(;" "==e.charAt(n)&&n<e.length;)if(n++,StringUtils.isInAlphabet(e.charAt(n))||"-"===e.charAt(n))return n;return-1}detectNextEndAttribute(t,e,n){for(;StringUtils.isInAlphabet(e.charAt(n))||"-"===e.charAt(n);)n++;if(":"==e.charAt(n))for(n++;StringUtils.isInAlphabet(e.charAt(n))||"-"===e.charAt(n);)n++;return n-1}detectValue(t,e,n,i,r){let s=r,o=t;if(null!==e&&(o=e+":"+t),-1==(s=ReadAhead.read(i,'="',s,!0)))return this.attributes.set(o,new XmlAttribute(t,e,null)),r;s++,LOG.debug(n,"Possible attribute value start at "+s);let a=s;for(;this.isAttributeContent(n,i,s);)s++;return s==r?this.attributes.set(o,new XmlAttribute(t,e,"")):this.attributes.set(o,new XmlAttribute(t,e,i.substring(a,s))),LOG.debug(n,"Found attribute content ending at "+(s-1)),-1!=(s=ReadAhead.read(i,'"',s,!0))?s++:LOG.error("Missing end quotes on attribute at position "+s),s}isAttributeContent(t,e,n){return-1==ReadAhead.read(e,"<",n)&&(-1==ReadAhead.read(e,">",n)&&-1==ReadAhead.read(e,'"',n))}}const LOG$1=new Logger("XmlCdata");class XmlCdata{constructor(t){this.value=t}dump(){this.dumpLevel(0)}dumpLevel(t){let e=":";for(let n=0;n<2*t;n++)e+=" ";LOG$1.info(e+this.value)}read(){return this.value}}const LOG$2=new Logger("XmlElement");class XmlElement{constructor(t,e,n,i){this.name=t,this.namespace=e,this.selfClosing=i,this.childElements=new List,this.attributes=new Map,this.namespaceUri=n}get fullName(){return null===this.namespace?this.name:this.namespace+":"+this.name}setAttribute(t,e){this.attributes.set(t,e)}getAttribute(t){return this.attributes.get(t)}containsAttribute(t){return this.attributes.contains(t)}clearAttribute(){this.attributes=new Map}setText(t){this.childElements=new List,this.addText(t)}addText(t){let e=new XmlCdata(t);this.childElements.add(e)}dump(){this.dumpLevel(0)}dumpLevel(t){let e=":";for(let n=0;n<2*t;n++)e+=" ";if(this.selfClosing)return void LOG$2.info(e+"<"+this.fullName+this.readAttributes()+"/>");LOG$2.info(e+"<"+this.fullName+this.readAttributes()+">"),this.childElements.forEach(function(e){return e.dumpLevel(t+1),!0}),LOG$2.info(e+"</"+this.fullName+">")}read(){let t="";return this.selfClosing?t=t+"<"+this.fullName+this.readAttributes()+"/>":(t=t+"<"+this.fullName+this.readAttributes()+">",this.childElements.forEach(function(e){return t+=e.read(),!0}),t=t+"</"+this.fullName+">")}readAttributes(){let t="";return this.attributes.forEach(function(e,n,i){let r=n.name;return null!==n.namespace&&void 0!==n.namespace&&(r=n.namespace+":"+n.name),t=t+" "+r,null!==n.value&&(t=t+'="'+n.value+'"'),!0},this),t}}const LOG$3=new Logger("ElementDetector");class ElementDetector{constructor(t){this.type="ElementDetector",this.namespaceUriMap=t,this.children=!1,this.found=!1,this.xmlCursor=null,this.element=null}createElement(){return this.element}isFound(){return this.found}hasChildren(){return this.children}detect(t,e){this.xmlCursor=e,LOG$3.debug(t,"Looking for opening element at position "+e.cursor);let n=new ElementBody,i=ElementDetector.detectOpenElement(t,e.xml,e.cursor,n);if(-1!=i){let r=null;null!==n.namespace&&void 0!==n.namespace&&(r=this.namespaceUriMap.get(n.namespace)),this.element=new XmlElement(n.name,n.namespace,r,!1),n.attributes.forEach(function(t,e,n){return n.element.attributes.set(t,e),!0},this),LOG$3.debug(t,"Found opening tag <"+this.element.fullName+"> from "+e.cursor+" to "+i),e.cursor=i+1,this.stop(t)||(this.children=!0),this.found=!0}}stop(t){LOG$3.debug(t,"Looking for closing element at position "+this.xmlCursor.cursor);let e=ElementDetector.detectEndElement(t,this.xmlCursor.xml,this.xmlCursor.cursor);if(-1!=e){let n=this.xmlCursor.xml.substring(this.xmlCursor.cursor+2,e);return LOG$3.debug(t,"Found closing tag </"+n+"> from "+this.xmlCursor.cursor+" to "+e),this.element.fullName!=n&&LOG$3.error("ERR: Mismatch between opening tag <"+this.element.fullName+"> and closing tag </"+n+"> When exiting to parent elemnt"),this.xmlCursor.cursor=e+1,!0}return!1}static detectOpenElement(t,e,n,i){return-1==(n=ReadAhead.read(e,"<",n))?-1:(n++,n=i.detectPositions(t+1,e,n),-1==(n=ReadAhead.read(e,">",n,!0))?-1:n)}static detectEndElement(t,e,n){return-1==(n=ReadAhead.read(e,"</",n))?-1:(n++,n=(new ElementBody).detectPositions(t+1,e,n),-1==(n=ReadAhead.read(e,">",n,!0))?-1:n)}}const LOG$4=new Logger("CdataDetector");class CdataDetector{constructor(){this.type="CdataDetector",this.value=null,this.found=!1}isFound(){return this.found}createElement(){return new XmlCdata(this.value)}detect(t,e){this.found=!1,this.value=null;let n=this.detectContent(t,e.xml,e.cursor,e.parentDomScaffold);-1!=n&&(this.found=!0,this.hasChildren=!1,this.value=e.xml.substring(e.cursor,n),e.cursor=n)}detectContent(t,e,n,i){LOG$4.debug(t,"Cdata start at "+n);let r=n;if(!CdataDetector.isContent(t,e,n))return LOG$4.debug(t,"No Cdata found"),-1;for(;CdataDetector.isContent(t,e,n)&&n<e.length;)n++;return LOG$4.debug(t,"Cdata end at "+(n-1)),null===i?(LOG$4.error("ERR: Content not allowed on root level in xml document"),-1):(LOG$4.debug(t,"Cdata found value is "+e.substring(r,n)),n)}static isContent(t,e,n){return-1==ReadAhead.read(e,"<",n)&&-1==ReadAhead.read(e,">",n)}}const LOG$5=new Logger("ClosingElementDetector");class ClosingElementDetector{constructor(t){this.type="ClosingElementDetector",this.namespaceUriMap=t,this.found=!1,this.element=null}createElement(){return this.element}isFound(){return this.found}detect(t,e){LOG$5.debug(t,"Looking for self closing element at position "+e.cursor);let n=new ElementBody,i=ClosingElementDetector.detectClosingElement(t,e.xml,e.cursor,n);-1!=i&&(this.element=new XmlElement(n.name,n.namespace,this.namespaceUriMap,!0),n.attributes.forEach(function(t,e,n){return n.element.setAttribute(t,e),!0},this),LOG$5.debug(t,"Found self closing tag <"+this.element.fullName+"/> from "+e.cursor+" to "+i),this.found=!0,e.cursor=i+1)}static detectClosingElement(t,e,n,i){return-1==(n=ReadAhead.read(e,"<",n))?-1:(n++,n=i.detectPositions(t+1,e,n),-1==(n=ReadAhead.read(e,"/>",n))?-1:n)}}class XmlCursor{constructor(t,e,n){this.xml=t,this.cursor=e,this.parentDomScaffold=n}eof(){return this.cursor>=this.xml.length}}const LOG$6=new Logger("DomScaffold");class DomScaffold{constructor(t){this.namespaceUriMap=t,this.element=null,this.childDomScaffolds=new List,this.detectors=new List,this.elementCreatedListener=null,this.detectors.add(new ElementDetector(this.namespaceUriMap)),this.detectors.add(new CdataDetector),this.detectors.add(new ClosingElementDetector(this.namespaceUriMap))}load(t,e,n){let i=new XmlCursor(t,e,null);this.loadDepth(1,i,n)}loadDepth(t,e,n){if(LOG$6.showPos(e.xml,e.cursor),LOG$6.debug(t,"Starting DomScaffold"),this.elementCreatedListener=n,e.eof())return LOG$6.debug(t,"Reached eof. Exiting"),!1;var i=null;if(this.detectors.forEach(function(n,r){return LOG$6.debug(t,"Starting "+n.type),n.detect(t+1,e),!n.isFound()||(i=n,!1)},this),null===i&&(e.cursor++,LOG$6.warn("WARN: No handler was found searching from position: "+e.cursor)),this.element=i.createElement(),i instanceof ElementDetector&&i.hasChildren()){let n=new Map;for(n.addAll(this.namespaceUriMap),this.element.attributes.forEach(function(t,e,i){"xmlns"===e.namespace&&n.set(e.name,e.value)},this);!i.stop(t+1)&&e.cursor<e.xml.length;){let i=e.parentDomScaffold,r=new DomScaffold(n);e.parentDomScaffold=r,r.loadDepth(t+1,e,this.elementCreatedListener),this.childDomScaffolds.add(r),e.parentDomScaffold=i}}LOG$6.showPos(e.xml,e.cursor)}getTree(t){if(null===this.element)return null;let e=this.notifyElementCreatedListener(this.element,t);return this.childDomScaffolds.forEach(function(t,n){let i=t.getTree(e);return null!==i&&n.element.childElements.add(i),!0},this),this.element}notifyElementCreatedListener(t,e){return null!==this.elementCreatedListener&&void 0!==this.elementCreatedListener?this.elementCreatedListener.elementCreated(t,e):null}}class DomTree{constructor(t,e){this.elementCreatedListener=e,this.xml=t,this.rootElement=null}load(){let t=new DomScaffold(new Map);t.load(this.xml,0,this.elementCreatedListener),this.rootElement=t.getTree()}dump(){this.rootElement.dump()}read(){return this.rootElement.read()}}export{CdataDetector,ClosingElementDetector,DomScaffold,DomTree,ElementBody,ElementDetector,ReadAhead,XmlAttribute,XmlCdata,XmlCursor,XmlElement};
